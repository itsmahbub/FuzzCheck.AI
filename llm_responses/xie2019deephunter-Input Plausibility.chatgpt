```json
{
  "value": "High",
  "why": "The paper explicitly designs and enforces plausibility constraints that operate across sequential fuzzing iterations. DeepHunter (1) defines a metamorphic mutation oracle (preserving human-recognizable semantics), (2) restricts affine transformations to at most one per mutation sequence to avoid cumulative geometric distortion, (3) enforces pixel-change bounds via L0 and L∞ thresholds and a reference-image mechanism that measures cumulative change across sequential mutations, and (4) implements these checks in the mutation algorithm (rejecting mutants that fail the plausibility check). The authors also validate this design with a user study showing low invalidity rates (e.g., 1.2% MNIST, 2.9% CIFAR-10, 0.8% ImageNet), demonstrating that faults found are induced by inputs that remain realistic for the task domain.",
  "evidence": "Section 3.2 (Transformation and Mutation), p.149: \"Definition 1. ... we define metamorphic mutation M on x, if ∀x' ∈ M(x), we have O(x') = O(x).\" (metamorphic oracle). \n\nSection 3.2.2 (Metamorphic Mutation), p.149: \"In order to keep the semantics of the mutants close to the original seed, we adopt a conservative strategy that selects the Affine Transformation to be used only once (we assume that mutation with only one affine transformation will not affect the semantics with the carefully selected parameters) as an image is more likely to be unrecognizable if it is changed by multiple affine transformations. A Pixel Value Transformation can be used multiple times for increasing the changeability, we use L0 and L∞ to constrain the pixel-level changes.\" \n\nEquation 1 (p.149): \"f(s,s') = { L∞(s,s') ≤ 255, if L0(s,s') < α × size(s); L∞(s,s') < β × 255, otherwise }\" (explicit plausibility constraint on pixel changes).\n\nDefinition 5 and Eq.2 (p.149): (reference-image / cumulative bounds) \"The reference image is either the original image (if there is no Affine Transformation) or the generated image after an Affine Transformation... For sequential mutations that include an Affine Transformation ... the L0 and L∞ between s0 and sn are computed as follows: L0(s0,sn) = L0(s0,sj-1) + L0(sj,sn); L∞(s0,sn) = MAX(L∞(s0,sj-1), L∞(sj,sn)).\"\n\nAlgorithm 2 and description (p.150): \"DeepHunter computes L0 and L∞ between the reference image s0 and the new mutant s' to check whether s' is meaningful (Line 12). If the Affine Transformation is selected, it updates the reference image... If there is no successful mutation after TRY_NUM trials, it adds the original image s into T.\" (implementation enforces plausibility and prevents drifting).\n\nRQ1 user study and results (Table 2 and text), p.153: \"Table 2: The number and ratio of invalid images generated by different mutation strategies\" showing DeepHunter invalidity: \"DeepHunter 60 (1.2%) [MNIST], 145 (2.9%) [CIFAR-10], 40 (0.8%) [ImageNet]\" and text: \"The conservative setting in DeepHunter confines the invalidity ratio to be even lower... the invalidity ratio is reduced to 2.9% for CIFAR-10 and 0.8% for ImageNet.\""
}
```